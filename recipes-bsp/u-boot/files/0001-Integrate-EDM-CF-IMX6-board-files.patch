From 2805f2cde454b87cc01494687d95449e6624f685 Mon Sep 17 00:00:00 2001
From: Scott Ellis <scott@jumpnowtek.com>
Date: Fri, 26 Jan 2018 15:43:42 -0500
Subject: [PATCH] Integrate EDM-CF-IMX6 board files

---
 arch/arm/include/asm/arch-mx6/imx-regs.h       |   3 +
 arch/arm/mach-imx/mx6/Kconfig                  |   6 +
 arch/arm/mach-imx/mx6/soc.c                    |   2 +-
 board/technexion/edm-cf-imx6/Kconfig           |  16 +
 board/technexion/edm-cf-imx6/MAINTAINERS       |   6 +
 board/technexion/edm-cf-imx6/Makefile          |   7 +
 board/technexion/edm-cf-imx6/README            |  26 +
 board/technexion/edm-cf-imx6/edm-cf-imx6.c     | 714 +++++++++++++++++++++++++
 board/technexion/edm-cf-imx6/edm-cf-imx6_spl.c | 566 ++++++++++++++++++++
 board/technexion/edm-cf-imx6/uEnv.txt          |   5 +
 configs/edm-cf-imx6_defconfig                  |  38 ++
 include/configs/edm-cf-imx6.h                  | 168 ++++++
 12 files changed, 1556 insertions(+), 1 deletion(-)
 create mode 100644 board/technexion/edm-cf-imx6/Kconfig
 create mode 100644 board/technexion/edm-cf-imx6/MAINTAINERS
 create mode 100644 board/technexion/edm-cf-imx6/Makefile
 create mode 100644 board/technexion/edm-cf-imx6/README
 create mode 100755 board/technexion/edm-cf-imx6/edm-cf-imx6.c
 create mode 100644 board/technexion/edm-cf-imx6/edm-cf-imx6_spl.c
 create mode 100644 board/technexion/edm-cf-imx6/uEnv.txt
 create mode 100644 configs/edm-cf-imx6_defconfig
 create mode 100644 include/configs/edm-cf-imx6.h

diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
index 86e2670..624ccec 100644
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h
@@ -346,6 +346,9 @@
 #define IOMUXC_SNVS_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x90000)
 #define SNVS_GPR_BASE_ADDR          (AIPS3_ARB_BASE_ADDR + 0x94000)
 #endif
+
+#define NOC_DDR_BASE_ADDR           (GPV0_BASE_ADDR + 0xB0000)
+
 /* Only for i.MX6SX */
 #define LCDIF2_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x24000)
 #define MX6SX_LCDIF1_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x20000)
diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index 540f2b2..9d2ba3a 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -129,6 +129,11 @@ config TARGET_COLIBRI_IMX6
 	select DM_SERIAL
 	select DM_THERMAL
 
+config TARGET_EDM_CF_IMX6
+	bool "edm-cf-imx6"
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+
 config TARGET_EMBESTMX6BOARDS
 	bool "embestmx6boards"
 	select BOARD_LATE_INIT
@@ -453,6 +458,7 @@ source "board/liebherr/mccmon6/Kconfig"
 source "board/logicpd/imx6/Kconfig"
 source "board/seco/Kconfig"
 source "board/solidrun/mx6cuboxi/Kconfig"
+source "board/technexion/edm-cf-imx6/Kconfig"
 source "board/technexion/pico-imx6ul/Kconfig"
 source "board/tbs/tbs2910/Kconfig"
 source "board/tqc/tqma6/Kconfig"
diff --git a/arch/arm/mach-imx/mx6/soc.c b/arch/arm/mach-imx/mx6/soc.c
index b724668..c6b7a94 100644
--- a/arch/arm/mach-imx/mx6/soc.c
+++ b/arch/arm/mach-imx/mx6/soc.c
@@ -451,7 +451,7 @@ __weak int board_mmc_get_env_dev(int devno)
 	return CONFIG_SYS_MMC_ENV_DEV;
 }
 
-static int mmc_get_boot_dev(void)
+int mmc_get_boot_dev(void)
 {
 	struct src *src_regs = (struct src *)SRC_BASE_ADDR;
 	u32 soc_sbmr = readl(&src_regs->sbmr1);
diff --git a/board/technexion/edm-cf-imx6/Kconfig b/board/technexion/edm-cf-imx6/Kconfig
new file mode 100644
index 0000000..06b45a0
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/Kconfig
@@ -0,0 +1,16 @@
+if TARGET_EDM_CF_IMX6
+
+config SYS_BOARD
+	default "edm-cf-imx6"
+
+config SYS_VENDOR
+	string
+	default "technexion"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "edm-cf-imx6"
+
+endif
diff --git a/board/technexion/edm-cf-imx6/MAINTAINERS b/board/technexion/edm-cf-imx6/MAINTAINERS
new file mode 100644
index 0000000..a036f1e
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/MAINTAINERS
@@ -0,0 +1,6 @@
+Technexion EDM-CF-IMX6 board
+M:	Richard Hu <richard.hu@technexion.com>
+S:	Maintained
+F:	board/edm-cf-imx6/
+F:	include/configs/edm-cf-imx6.h
+F:	configs/edm-cf-imx6_defconfig
diff --git a/board/technexion/edm-cf-imx6/Makefile b/board/technexion/edm-cf-imx6/Makefile
new file mode 100644
index 0000000..e260164
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/Makefile
@@ -0,0 +1,7 @@
+#
+# (C) Copyright 2015 Technexion Ltd.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := edm-cf-imx6.o edm-cf-imx6_spl.o
diff --git a/board/technexion/edm-cf-imx6/README b/board/technexion/edm-cf-imx6/README
new file mode 100644
index 0000000..8cbea99
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/README
@@ -0,0 +1,26 @@
+U-Boot for edm_cf_imx6
+--------------------
+
+The version of u-boot for edm_cf_imx6 with SPL.
+
+The u-boot is suitable for i.mx6 solo, dual lite, quad.
+
+For more details, please refer to:
+http://www.technexion.com
+
+Building U-boot for edm_cf_imx6
+-----------------------------
+
+To build U-Boot for i.mx6 solo, dual lite, quad:
+
+$ make edm-cf-imx6_defconfig
+$ make
+
+Flashing U-boot into the SD card
+--------------------------------
+
+$ sudo dd if=SPL of=/dev/$dev bs=512 seek=2; sync
+
+$ Copy u-boot.img into 1st FAT partition of SD card
+
+- Power up the board and U-boot messages will appear in the serial console.
diff --git a/board/technexion/edm-cf-imx6/edm-cf-imx6.c b/board/technexion/edm-cf-imx6/edm-cf-imx6.c
new file mode 100755
index 0000000..b2f5997
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/edm-cf-imx6.c
@@ -0,0 +1,714 @@
+/*
+ * Copyright (C) 2015 Technexion Ltd.
+ *
+ * Author: Richard Hu <richard.hu@technexion.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/video.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <phy.h>
+#include <input.h>
+#include <i2c.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#ifdef CONFIG_CMD_SATA
+#include <asm/mach-imx/sata.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_BASEBOARD_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define USDHC1_CD_GPIO		IMX_GPIO_NR(1, 2)
+#define USDHC3_CD_GPIO		IMX_GPIO_NR(3, 9)
+#define ETH_PHY_RESET		IMX_GPIO_NR(3, 29)
+#define ETH_PHY_AR8035_POWER	IMX_GPIO_NR(7, 13)
+#define EDM_SOM_DET_R149	IMX_GPIO_NR(2, 28)
+
+#define PMIC_I2C_ADDR 0x08
+
+#define STRING(s) #s
+
+#define RETURN_SOM_TYPE(def)						\
+if (is_mx6dqp()) {							\
+	return STRING(imx6qp-def);					\
+} else if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) {	\
+	return STRING(imx6q-def);					\
+} else {								\
+	return STRING(imx6dl-def);					\
+}
+
+
+static bool with_pmic = false;
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	IOMUX_PADS(PAD_SD1_CLK__SD1_CLK    | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_CMD__SD1_CMD    | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+	/* Carrier MicroSD Card Detect */
+	IOMUX_PADS(PAD_GPIO_2__GPIO1_IO02  | MUX_PAD_CTRL(USDHC_BASEBOARD_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	/* SOM MicroSD Card Detect */
+	IOMUX_PADS(PAD_EIM_DA9__GPIO3_IO09  | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC    | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TXC__RGMII_TXC  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD0__RGMII_TD0  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD1__RGMII_TD1  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD2__RGMII_TD2  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD3__RGMII_TD3  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TX_CTL__RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_REF_CLK__ENET_TX_CLK  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RXC__RGMII_RXC  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD0__RGMII_RD0  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD1__RGMII_RD1  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD2__RGMII_RD2  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD3__RGMII_RD3  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RX_CTL__RGMII_RX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	/* AR8031/AR8035 PHY Reset */
+	IOMUX_PADS(PAD_EIM_D29__GPIO3_IO29    | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_ar8035_power_pads[] = {
+	/* AR8035 POWER */
+	IOMUX_PADS(PAD_GPIO_18__GPIO7_IO13    | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const som_detection_pads[] = {
+	/* R149 */
+	IOMUX_PADS(PAD_EIM_EB0__GPIO2_IO28  | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static void setup_iomux_uart(void)
+{
+	SETUP_IOMUX_PADS(uart1_pads);
+}
+
+static void setup_iomux_enet(void)
+{
+	SETUP_IOMUX_PADS(enet_pads);
+
+	if (with_pmic) {
+		SETUP_IOMUX_PADS(enet_ar8035_power_pads);
+		/* enable AR8035 POWER */
+		gpio_direction_output(ETH_PHY_AR8035_POWER, 0);
+	}
+	/* wait until 3.3V of PHY and clock become stable */
+	mdelay(10);
+	/* Reset AR8031/AR8035 PHY */
+	gpio_direction_output(ETH_PHY_RESET, 0);
+	mdelay(10);
+	gpio_set_value(ETH_PHY_RESET, 1);
+	udelay(100);
+}
+
+static void setup_iomux_som_detection(void)
+{
+	SETUP_IOMUX_PADS(som_detection_pads);
+}
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+/* defined in arch/arm/mach-imx/mx6/soc.c */
+int mmc_get_boot_dev(void);
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	u32 index = 0;
+
+	/*
+	 * Following map is done:
+	 * (USDHC)>-----(Physical Port)
+	 * usdhc3>------SOM MicroSD/MMC
+	 * usdhc1>------Carrier board MicroSD
+	 * Always set boot USDHC as mmc0
+	 */
+
+	SETUP_IOMUX_PADS(usdhc3_pads);
+	gpio_direction_input(USDHC3_CD_GPIO);
+
+	SETUP_IOMUX_PADS(usdhc1_pads);
+	gpio_direction_input(USDHC1_CD_GPIO);
+
+	index = mmc_get_boot_dev();
+	printf("mmcbootdev: %d\n", index);
+
+	switch (index) {
+	case 0:
+		usdhc_cfg[0].esdhc_base = USDHC1_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+		usdhc_cfg[0].max_bus_width = 4;
+		usdhc_cfg[1].esdhc_base = USDHC3_BASE_ADDR;
+		usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		usdhc_cfg[1].max_bus_width = 4;
+		break;
+	case 2:
+	default:
+		usdhc_cfg[0].esdhc_base = USDHC3_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		usdhc_cfg[0].max_bus_width = 4;
+		usdhc_cfg[1].esdhc_base = USDHC1_BASE_ADDR;
+		usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+		usdhc_cfg[1].max_bus_width = 4;
+		break;
+	}
+
+	for (index = 0; index < CONFIG_SYS_FSL_USDHC_NUM; ++index) {
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[index]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* To enable AR8031/AR8035 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	if (with_pmic) {
+		/* AR8035 */
+		val &= 0xffe7;
+		val |= 0x18;
+	} else {
+		/* AR8031 */
+		val &= 0xffe3;
+		val |= 0x18;
+	}
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+struct i2c_pads_info mx6q_i2c1_pad_info = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_EIM_D21__I2C1_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_EIM_D21__GPIO3_IO21
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 21)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_EIM_D28__I2C1_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_EIM_D28__GPIO3_IO28
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 28)
+	}
+};
+
+struct i2c_pads_info mx6dl_i2c1_pad_info = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_EIM_D21__I2C1_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_EIM_D21__GPIO3_IO21
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 21)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_EIM_D28__I2C1_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_EIM_D28__GPIO3_IO28
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 28)
+	}
+};
+
+struct i2c_pads_info mx6q_i2c3_pad_info = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_GPIO_5__I2C3_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_5__GPIO1_IO05
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 5)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_GPIO_16__I2C3_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_16__GPIO7_IO11
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(7, 11)
+	}
+};
+
+struct i2c_pads_info mx6dl_i2c3_pad_info = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_GPIO_5__I2C3_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_GPIO_5__GPIO1_IO05
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 5)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_GPIO_16__I2C3_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_GPIO_16__GPIO7_IO11
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(7, 11)
+	}
+};
+
+#if defined(CONFIG_VIDEO_IPUV3)
+struct i2c_pads_info mx6q_i2c2_pad_info = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_KEY_COL3__I2C2_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO4_IO12
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_KEY_ROW3__I2C2_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO4_IO13
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+struct i2c_pads_info mx6dl_i2c2_pad_info = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_KEY_COL3__I2C2_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_KEY_COL3__GPIO4_IO12
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_KEY_ROW3__I2C2_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_KEY_ROW3__GPIO4_IO13
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+static iomux_v3_cfg_t const ft5x06_wvga_pads[] = {
+	IOMUX_PADS(PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK),
+	IOMUX_PADS(PAD_DI0_PIN2__IPU1_DI0_PIN02), /* HSync */
+	IOMUX_PADS(PAD_DI0_PIN3__IPU1_DI0_PIN03), /* VSync */
+	IOMUX_PADS(PAD_DI0_PIN4__IPU1_DI0_PIN04	| MUX_PAD_CTRL(PAD_CTL_DSE_120ohm)), /* Contrast */
+	IOMUX_PADS(PAD_DI0_PIN15__IPU1_DI0_PIN15), /* DISP0_DRDY */
+	IOMUX_PADS(PAD_DISP0_DAT0__IPU1_DISP0_DATA00),
+	IOMUX_PADS(PAD_DISP0_DAT1__IPU1_DISP0_DATA01),
+	IOMUX_PADS(PAD_DISP0_DAT2__IPU1_DISP0_DATA02),
+	IOMUX_PADS(PAD_DISP0_DAT3__IPU1_DISP0_DATA03),
+	IOMUX_PADS(PAD_DISP0_DAT4__IPU1_DISP0_DATA04),
+	IOMUX_PADS(PAD_DISP0_DAT5__IPU1_DISP0_DATA05),
+	IOMUX_PADS(PAD_DISP0_DAT6__IPU1_DISP0_DATA06),
+	IOMUX_PADS(PAD_DISP0_DAT7__IPU1_DISP0_DATA07),
+	IOMUX_PADS(PAD_DISP0_DAT8__IPU1_DISP0_DATA08),
+	IOMUX_PADS(PAD_DISP0_DAT9__IPU1_DISP0_DATA09),
+	IOMUX_PADS(PAD_DISP0_DAT10__IPU1_DISP0_DATA10),
+	IOMUX_PADS(PAD_DISP0_DAT11__IPU1_DISP0_DATA11),
+	IOMUX_PADS(PAD_DISP0_DAT12__IPU1_DISP0_DATA12),
+	IOMUX_PADS(PAD_DISP0_DAT13__IPU1_DISP0_DATA13),
+	IOMUX_PADS(PAD_DISP0_DAT14__IPU1_DISP0_DATA14),
+	IOMUX_PADS(PAD_DISP0_DAT15__IPU1_DISP0_DATA15),
+	IOMUX_PADS(PAD_DISP0_DAT16__IPU1_DISP0_DATA16),
+	IOMUX_PADS(PAD_DISP0_DAT17__IPU1_DISP0_DATA17),
+	IOMUX_PADS(PAD_DISP0_DAT18__IPU1_DISP0_DATA18),
+	IOMUX_PADS(PAD_DISP0_DAT19__IPU1_DISP0_DATA19),
+	IOMUX_PADS(PAD_DISP0_DAT20__IPU1_DISP0_DATA20),
+	IOMUX_PADS(PAD_DISP0_DAT21__IPU1_DISP0_DATA21),
+	IOMUX_PADS(PAD_DISP0_DAT22__IPU1_DISP0_DATA22),
+	IOMUX_PADS(PAD_DISP0_DAT23__IPU1_DISP0_DATA23),
+	IOMUX_PADS(PAD_SD4_DAT2__GPIO2_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL)), /* DISP0_BKLEN */
+	IOMUX_PADS(PAD_SD4_DAT3__GPIO2_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL)), /* DISP0_VDDEN */
+};
+
+static void setup_iomux_i2c(void)
+{
+	if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D) ||
+		is_cpu_type(MXC_CPU_MX6QP) || is_cpu_type(MXC_CPU_MX6DP)) {
+		//setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6q_i2c1_pad_info);
+		setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6q_i2c2_pad_info);
+		setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6q_i2c3_pad_info);
+	} else {
+		//setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dl_i2c1_pad_info);
+		setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dl_i2c2_pad_info);
+		setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dl_i2c3_pad_info);
+	}
+}
+
+static const char* som_type(void)
+{
+	/*
+	 * EDM boots from i-NAND or SD1
+	 */
+	gpio_direction_input(EDM_SOM_DET_R149);
+
+	if (!gpio_get_value(EDM_SOM_DET_R149)) {
+		if (with_pmic) {
+			RETURN_SOM_TYPE(edm1-cf-pmic)
+		} else {
+			RETURN_SOM_TYPE(edm1-cf)
+		}
+	} else {
+		if (with_pmic) {
+			RETURN_SOM_TYPE(edm2-cf-pmic)
+		} else {
+			RETURN_SOM_TYPE(edm2-cf)
+		}
+	}
+}
+
+#define CONFIG_I2C_PMIC		2
+
+/* setup board specific PMIC */
+int power_init_board(void)
+{
+	struct pmic *p;
+	u32 reg;
+
+	/* configure PFUZE100 PMIC */
+	power_pfuze100_init(CONFIG_I2C_PMIC);
+	p = pmic_get("PFUZE100");
+	if (p && !pmic_probe(p)) {
+		pmic_reg_read(p, PFUZE100_DEVICEID, &reg);
+		printf("PMIC:  PFUZE100 ID=0x%02x\n", reg);
+		with_pmic = true;
+
+		/* Set VGEN2 to 1.5V and enable */
+		pmic_reg_read(p, PFUZE100_VGEN2VOL, &reg);
+		reg &= ~(LDO_VOL_MASK);
+		reg |= (LDOA_1_50V | (1 << (LDO_EN)));
+		pmic_reg_write(p, PFUZE100_VGEN2VOL, reg);
+	}
+
+	return 0;
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	imx_enable_hdmi_phy();
+}
+
+static int detect_i2c(struct display_info_t const *dev)
+{
+	return (0 == i2c_set_bus_num(dev->bus)) &&
+			(0 == i2c_probe(dev->addr));
+}
+
+static void enable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)
+				IOMUXC_BASE_ADDR;
+
+	/* set CH0 data width to 24bit (IOMUXC_GPR2:5 0=18bit, 1=24bit) */
+	u32 reg = readl(&iomux->gpr[2]);
+	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT;
+	writel(reg, &iomux->gpr[2]);
+
+	/* Enable Backlight - use GPIO for Brightness adjustment */
+	SETUP_IOMUX_PAD(PAD_SD4_DAT1__GPIO2_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	gpio_direction_output(IMX_GPIO_NR(2, 9), 1);
+
+	SETUP_IOMUX_PAD(PAD_SD4_DAT0__GPIO2_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	gpio_direction_output(IMX_GPIO_NR(2, 8), 1);
+}
+
+static void enable_ft5x06_wvga(struct display_info_t const *dev)
+{
+	SETUP_IOMUX_PADS(ft5x06_wvga_pads);
+
+	gpio_direction_output(IMX_GPIO_NR(2, 10), 1);
+	gpio_direction_output(IMX_GPIO_NR(2, 11), 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt = IPU_PIX_FMT_RGB24,
+	.detect = NULL,
+	.enable = enable_lvds,
+	.mode	= {
+		.name		= "hj070na",
+		.refresh	= 60,
+		.xres		= 1024,
+		.yres		= 600,
+		.pixclock	= 15385,
+		.left_margin	= 220,
+		.right_margin	= 40,
+		.upper_margin	= 21,
+		.lower_margin	= 7,
+		.hsync_len	= 60,
+		.vsync_len	= 10,
+		.sync		= FB_SYNC_EXT,
+		.vmode		= FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= 1,
+	.addr	= 0x38,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_i2c,
+	.enable	= enable_ft5x06_wvga,
+	.mode	= {
+		.name           = "FT5x06-WVGA",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 30303,
+		.left_margin    = 45,
+		.right_margin   = 210,
+		.upper_margin   = 22,
+		.lower_margin   = 22,
+		.hsync_len      = 1,
+		.vsync_len      = 1,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	reg = __raw_readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		| MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+		 | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	 reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+		| IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+		| IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+		| IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+		| IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT
+		| IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+		| IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT
+		| IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0
+		| IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+	reg = readl(&iomux->gpr[3]);
+
+	reg = (reg & ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK
+		| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+		| (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+		<< IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+
+	return cpu_eth_init(bis);
+}
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+	return 0;
+}
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	  MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	  MAKE_CFGVAL(0x40, 0x20, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+#define SETUP_FDT_FILE
+
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	if (is_mx6dq())
+		env_set("board_rev", "MX6Q");
+	else
+		env_set("board_rev", "MX6DL");
+
+	env_set("board_name", som_type());
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	setup_iomux_i2c();
+	setup_iomux_som_detection();
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("SOM: %s\n", som_type());
+	printf("Available baseboard: elf, fairy, mimas, tc0700, tc1000\n");
+
+	return 0;
+}
diff --git a/board/technexion/edm-cf-imx6/edm-cf-imx6_spl.c b/board/technexion/edm-cf-imx6/edm-cf-imx6_spl.c
new file mode 100644
index 0000000..485137f
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/edm-cf-imx6_spl.c
@@ -0,0 +1,566 @@
+/*
+ * Copyright (C) 2015 Technexion Ltd.
+ *
+ * Author: Richard Hu <richard.hu@technexion.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <spl.h>
+#ifdef CONFIG_CMD_SATA
+#include <asm/mach-imx/sata.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_SPL_BUILD)
+#include <asm/arch/mx6-ddr.h>
+/*
+ * Driving strength:
+ *   0x30 == 40 Ohm
+ *   0x28 == 48 Ohm
+ */
+
+#define IMX6DQ_DRIVE_STRENGTH		0x30
+#define IMX6SDL_DRIVE_STRENGTH		0x28
+#define IMX6QP_DRIVE_STRENGTH		0x28
+
+/* configure MX6Q/DUAL mmdc DDR io registers */
+static struct mx6dq_iomux_ddr_regs mx6dq_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_cas = IMX6DQ_DRIVE_STRENGTH,
+	.dram_ras = IMX6DQ_DRIVE_STRENGTH,
+	.dram_reset = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6DQ_DRIVE_STRENGTH,
+};
+
+/* configure MX6Q/DUAL mmdc GRP io registers */
+static struct mx6dq_iomux_grp_regs mx6dq_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6DQ_DRIVE_STRENGTH,
+};
+
+/* configure MX6SOLO/DUALLITE mmdc DDR io registers */
+struct mx6sdl_iomux_ddr_regs mx6sdl_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_cas = IMX6SDL_DRIVE_STRENGTH,
+	.dram_ras = IMX6SDL_DRIVE_STRENGTH,
+	.dram_reset = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6SDL_DRIVE_STRENGTH,
+};
+
+/* configure MX6SOLO/DUALLITE mmdc GRP io registers */
+struct mx6sdl_iomux_grp_regs mx6sdl_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6SDL_DRIVE_STRENGTH,
+};
+
+/* H5T04G63AFR-PB */
+static struct mx6_ddr3_cfg h5t04g63afr = {
+	.mem_speed = 1600,
+	.density = 4,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+/* H5TQ2G63DFR-H9 */
+static struct mx6_ddr3_cfg h5tq2g63dfr = {
+	.mem_speed = 1333,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1350,
+	.trcmin = 4950,
+	.trasmin = 3600,
+};
+
+/* H5TQ2G63FFR-H9 for i.mx6Solo/DL operating DDR at 400MHz */
+static struct mx6_ddr3_cfg h5tq2g63ffr_800mhz = {
+	.mem_speed = 800,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1500,
+	.trcmin = 5250,
+	.trasmin = 3750,
+};
+
+/*
+ * calibration - these are the various CPU/DDR3 combinations we support
+ */
+/*
+static struct mx6_mmdc_calibration mx6q_2g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x00000000,
+	.p0_mpwldectrl1 = 0x00000000,
+	.p1_mpwldectrl0 = 0x00000000,
+	.p1_mpwldectrl1 = 0x00000000,
+	.p0_mpdgctrl0 = 0x032C0340,
+	.p0_mpdgctrl1 = 0x03300324,
+	.p1_mpdgctrl0 = 0x032C0338,
+	.p1_mpdgctrl1 = 0x03300274,
+	.p0_mprddlctl = 0x423A383E,
+	.p1_mprddlctl = 0x3638323E,
+	.p0_mpwrdlctl = 0x363C4640,
+	.p1_mpwrdlctl = 0x4034423C,
+};
+*/
+static struct mx6_mmdc_calibration mx6q_2g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x001f001f,
+	.p0_mpwldectrl1 = 0x001f001f,
+	.p1_mpwldectrl0 = 0x001f001f,
+	.p1_mpwldectrl1 = 0x001f001f,
+	.p0_mpdgctrl0 = 0x4301030d,
+	.p0_mpdgctrl1 = 0x03020277,
+	.p1_mpdgctrl0 = 0x4300030a,
+	.p1_mpdgctrl1 = 0x02780248,
+	.p0_mprddlctl = 0x4536393b,
+	.p1_mprddlctl = 0x36353441,
+	.p0_mpwrdlctl = 0x41414743,
+	.p1_mpwrdlctl = 0x462f453f,
+};
+
+/* DDR 64bit 2GB */
+static struct mx6_ddr_sysinfo mem_q = {
+	.dsize		= 2,
+	.cs1_mirror	= 0,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density	= 32,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 0,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x23,
+	.sde_to_rst	= 0x10,
+	.refsel = 1,	/* Refresh cycles at 32KHz */
+	.refr = 3,	/* 4 refresh commands per refresh cycle */
+};
+
+static struct mx6_mmdc_calibration mx6d_1g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x00000000,
+	.p0_mpwldectrl1 = 0x00000000,
+	.p1_mpwldectrl0 = 0x00000000,
+	.p1_mpwldectrl1 = 0x00000000,
+	.p0_mpdgctrl0 = 0x03280334,
+	.p0_mpdgctrl1 = 0x03280320,
+	.p1_mpdgctrl0 = 0x0330033C,
+	.p1_mpdgctrl1 = 0x033C0278,
+	.p0_mprddlctl = 0x423A3A3E,
+	.p1_mprddlctl = 0x3C3E3842,
+	.p0_mpwrdlctl = 0x36384240,
+	.p1_mpwrdlctl = 0x4A384440,
+};
+
+static struct mx6_mmdc_calibration mx6dl_1g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x003E0047,
+	.p0_mpwldectrl1 = 0x00300036,
+	.p1_mpwldectrl0 = 0x0018001B,
+	.p1_mpwldectrl1 = 0x0010002C,
+	.p0_mpdgctrl0 = 0x02380234,
+	.p0_mpdgctrl1 = 0x02300230,
+	.p1_mpdgctrl0 = 0x0218021C,
+	.p1_mpdgctrl1 = 0x0210020C,
+	.p0_mprddlctl = 0x40464846,
+	.p1_mprddlctl = 0x40444640,
+	.p0_mpwrdlctl = 0x3A302E30,
+	.p1_mpwrdlctl = 0x3630302C,
+};
+
+static struct mx6_mmdc_calibration mx6s_512m_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x0033003C,
+	.p0_mpwldectrl1 = 0x002E0032,
+	.p0_mpdgctrl0 = 0x02300224,
+	.p0_mpdgctrl1 = 0x02140218,
+	.p0_mprddlctl = 0x40444A48,
+	.p0_mpwrdlctl = 0x38362E2E,
+};
+
+/* DDR 64bit 1GB */
+static struct mx6_ddr_sysinfo mem_dl = {
+	.dsize		= 2,
+	.cs1_mirror	= 0,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density	= 32,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 0,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x23,
+	.sde_to_rst	= 0x10,
+};
+
+/* DDR 32bit 512MB */
+static struct mx6_ddr_sysinfo mem_s = {
+	.dsize		= 1,
+	.cs1_mirror	= 0,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density	= 32,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 0,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x23,
+	.sde_to_rst	= 0x10,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FC03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF00000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000F3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+}
+
+static void spl_dram_init_imx6qp_lpddr3(void)
+{
+	 /* i.MX6QP */
+	/* DDR IO TYPE */
+	writel(0x000C0000, IOMUXC_BASE_ADDR + 0x798);
+	writel(0x00000000, IOMUXC_BASE_ADDR + 0x758);
+	/* Clock */
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x588);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x594);
+	/* Address */
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x56c);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x578);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x74c);
+	/* Control */
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x57c);//fix to apply for LPDDR2
+
+	writel(0x00000000, IOMUXC_BASE_ADDR + 0x58c);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x59c);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5a0);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x78c);
+	/* Data Strobe */
+	writel(0x00020000, IOMUXC_BASE_ADDR + 0x750);
+
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5a8);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5b0);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x524);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x51c);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x518);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x50c);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5b8);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5c0);
+	/* Data */
+	writel(0x00020000, IOMUXC_BASE_ADDR + 0x774);
+
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x784);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x788);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x794);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x79c);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x7a0);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x7a4);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x7a8);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x748);
+
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5ac);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5b4);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x528);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x520);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x514);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x510);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5bc);
+	writel(IMX6QP_DRIVE_STRENGTH, IOMUXC_BASE_ADDR + 0x5c4);
+
+	/* MMDC0_MDSCR
+	   set the Configuration request bit during MMDC set up */
+	writel(0x00008000, MMDC_P0_BASE_ADDR + 0x01c);
+
+	/* Calibrations */
+	/* ZQ */
+	writel(0xa1390003, MMDC_P0_BASE_ADDR + 0x800);
+	/* write leveling */
+	writel(0x00060004, MMDC_P0_BASE_ADDR + 0x80c);
+	writel(0x000B0004, MMDC_P0_BASE_ADDR + 0x810);
+	writel(0x00000004, MMDC_P1_BASE_ADDR + 0x80c);
+	writel(0x00000000, MMDC_P1_BASE_ADDR + 0x810);
+	/* DQS gating, read delay, write delay calibration values
+	 based on calibration compare of 0x00ffff00  */
+	writel(0x03040314, MMDC_P0_BASE_ADDR + 0x83c);
+	writel(0x03080300, MMDC_P0_BASE_ADDR + 0x840);
+	writel(0x03000310, MMDC_P1_BASE_ADDR + 0x83c);
+	writel(0x0268023C, MMDC_P1_BASE_ADDR + 0x840);
+
+	writel(0x4034363A, MMDC_P0_BASE_ADDR + 0x848);
+	writel(0x36302C3C, MMDC_P1_BASE_ADDR + 0x848);
+
+	writel(0x3E3E4046, MMDC_P0_BASE_ADDR + 0x850);
+	writel(0x483A4844, MMDC_P1_BASE_ADDR + 0x850);
+
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x81c);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x820);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x824);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x828);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x81c);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x820);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x824);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x828);
+
+	writel(0x24912489, MMDC_P0_BASE_ADDR + 0x8c0);
+	writel(0x24914452, MMDC_P1_BASE_ADDR + 0x8c0);
+
+	writel(0x00000800, MMDC_P0_BASE_ADDR + 0x8b8);
+	writel(0x00000800, MMDC_P1_BASE_ADDR + 0x8b8);
+	/* MMDC init:
+	  in DDR3, 64-bit mode, only MMDC0 is initiated: */
+	writel(0x00020036, MMDC_P0_BASE_ADDR + 0x004);
+	writel(0x09444040, MMDC_P0_BASE_ADDR + 0x008);
+	writel(0x898E79A4, MMDC_P0_BASE_ADDR + 0x00c);
+	writel(0xDB538F64, MMDC_P0_BASE_ADDR + 0x010);
+	writel(0x01FF00DD, MMDC_P0_BASE_ADDR + 0x014);
+
+	writel(0x00011740, MMDC_P0_BASE_ADDR + 0x018);
+	writel(0x00008000, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x000026D2, MMDC_P0_BASE_ADDR + 0x02c);
+	writel(0x008E1023, MMDC_P0_BASE_ADDR + 0x030);
+	writel(0x00000047, MMDC_P0_BASE_ADDR + 0x040);
+
+	writel(0x14420000, MMDC_P0_BASE_ADDR + 0x400);
+	writel(0x841A0000, MMDC_P0_BASE_ADDR + 0x000);
+	writel(0x00400c58, MMDC_P0_BASE_ADDR + 0x890);
+
+	/* add noc DDR configuration */
+	writel(0x00000000, NOC_DDR_BASE_ADDR + 0x008);
+	writel(0x2871C39B, NOC_DDR_BASE_ADDR + 0x00c);
+	writel(0x000005B4, NOC_DDR_BASE_ADDR + 0x038);
+	writel(0x00000040, NOC_DDR_BASE_ADDR + 0x014);
+	writel(0x00000020, NOC_DDR_BASE_ADDR + 0x028);
+	writel(0x00000020, NOC_DDR_BASE_ADDR + 0x02c);
+
+	writel(0x02088032, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x00008033, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x00048031, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x19308030, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x04008040, MMDC_P0_BASE_ADDR + 0x01c);
+
+	writel(0x00007800, MMDC_P0_BASE_ADDR + 0x020);
+	writel(0x00022227, MMDC_P0_BASE_ADDR + 0x818);
+	writel(0x00022227, MMDC_P1_BASE_ADDR + 0x818);
+	writel(0x00025576, MMDC_P0_BASE_ADDR + 0x004);
+	writel(0x00011006, MMDC_P0_BASE_ADDR + 0x404);
+	writel(0x00000000, MMDC_P0_BASE_ADDR + 0x01c);
+}
+
+#ifdef CONFIG_IMX6_SPREAD_SPECTRUM
+static void enable_spread_spectrum(void)
+{
+	asm volatile (
+		"ldr r0, =#0x20C4000\n"			// base register CCM_BASE_ADDR
+		"ldr r1, [r0,#0x18]\n"			// get the CCM_CMCMR
+		"ldr r3, [r0,#0x18]\n"			// restore it later
+		"and r1, r1, #0xffffcfff\n"		// set r1 to set periph_clk2_sel to "01 derive clock from osc_clk (pll1_ref_clk)"
+		"orr r1, r1, #0x00001000\n"		//
+		"str r1, [r0,#0x18]\n"			// the set it
+		"ldr r1, [r0,#0x14]\n"			// load the CCM_CBCDR
+		"ldr r2, [r0,#0x14]\n"			// restore it later
+		"orr r1, r1, #0x02000000\n"		// set r1 to set periph_clk_sel to "1 derive clock from periph_clk2_clk clock source."
+		"str r1, [r0,#0x14]\n"			// then set it
+
+		"ldr r0, =0x020c8000\n"			//
+		"ldr r1, [r0,#0x30]\n"			// get the CCM_ANALOG_PLL_SYS
+		"orr r1, r1, #0x00010000\n"		// set to bypass
+		"str r1, [r0,#0x30]\n"
+
+		"orr r1, r1, #0x00011000\n"		// set to power down (the docs don't say if there needs to be a delay from the above)
+		"str r1, [r0,#0x30]\n"
+
+		"ldr r1, =0x00001770\n"			// set the denominator to 6000 dec
+		"str r1, [r0,#0x60]\n"
+		"ldr r1, =0x0bb88006\n"			// set the STOP t0 3000 (xbb8) and the STEP to 6 (x006)
+										// giving: range=24M * 3000/6000 = 12M, step=24M * 6 / 6000 = 24khz
+		"str r1, [r0,#0x40]\n"
+
+		"ldr r1, [r0,#0x30]\n"
+
+		"and r1, r1, #0xFFFFEFFF\n"		// power up
+		"str r1, [r0,#0x30]\n"
+
+		"and r1, r1, #0xFFFEFFFF\n"		// enable (the docs don't say if there needs to be a delay from the above)
+		"str r1, [r0,#0x30]\n"
+
+		"ldr r4, =0x0\n"
+	);
+
+	//udelay(10);
+	asm volatile (
+		"pu_delay:\n"				// wait until the pll is locked
+		"ldr r1, [r0,#0xD0]\n"
+		"tst r1, #0x80000000\n"
+		"bne pu_delay\n"
+	);
+
+
+	asm volatile (
+		"ldr r0, =#0x20C4000\n"			// restore and done
+		"str r2, [r0,#0x14]\n"
+		"str r3, [r0,#0x18]\n"
+	);
+}
+#endif
+
+static void spl_dram_init(void)
+{
+#ifdef CONFIG_IMX6_SPREAD_SPECTRUM
+	enable_spread_spectrum();
+#endif
+	if (is_mx6dqp()) {
+		spl_dram_init_imx6qp_lpddr3();
+	} else {
+		switch (get_cpu_type()) {
+		case MXC_CPU_MX6SOLO:
+			mx6sdl_dram_iocfg(32, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+			mx6_dram_cfg(&mem_s, &mx6s_512m_mmdc_calib, &h5tq2g63ffr_800mhz);
+			break;
+		case MXC_CPU_MX6DL:
+			mx6sdl_dram_iocfg(64, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+			mx6_dram_cfg(&mem_dl, &mx6dl_1g_mmdc_calib, &h5tq2g63dfr);
+			break;
+		case MXC_CPU_MX6D:
+			mx6sdl_dram_iocfg(64, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+			mx6_dram_cfg(&mem_dl, &mx6d_1g_mmdc_calib, &h5tq2g63dfr);
+			break;
+		case MXC_CPU_MX6Q:
+			mx6dq_dram_iocfg(64, &mx6dq_ddr_ioregs, &mx6dq_grp_ioregs);
+			mx6_dram_cfg(&mem_q, &mx6q_2g_mmdc_calib, &h5t04g63afr);
+			break;
+		}
+	}
+}
+
+void board_init_f(ulong dummy)
+{
+	ccgr_init();
+
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	gpr_init();
+
+	/* iomux */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+#ifndef CONFIG_SILENT_CONSOLE
+	preloader_console_init();
+#endif
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+#endif
diff --git a/board/technexion/edm-cf-imx6/uEnv.txt b/board/technexion/edm-cf-imx6/uEnv.txt
new file mode 100644
index 0000000..50f050a
--- /dev/null
+++ b/board/technexion/edm-cf-imx6/uEnv.txt
@@ -0,0 +1,5 @@
+displayinfo=video=mxcfb0:dev=ldb,1024x600@60,if=RGB24,bpp=32
+mmcargs=setenv bootargs console=${console},${baudrate} root=${mmcroot} ${displayinfo}
+baseboard=fairy
+bootcmd_mmc=run loadimage;run mmcboot;
+uenvcmd=run bootcmd_mmc
diff --git a/configs/edm-cf-imx6_defconfig b/configs/edm-cf-imx6_defconfig
new file mode 100644
index 0000000..1f0d9a6
--- /dev/null
+++ b/configs/edm-cf-imx6_defconfig
@@ -0,0 +1,38 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_TARGET_EDM_CF_IMX6=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_VIDEO=y
+CONFIG_CMD_HDMIDETECT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,MX6QDL"
+# CONFIG_CONSOLE_MUX is not set
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SPL=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SATA=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_DM=y
+CONFIG_PHYLIB=y
+CONFIG_DM_THERMAL=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff --git a/include/configs/edm-cf-imx6.h b/include/configs/edm-cf-imx6.h
new file mode 100644
index 0000000..3852833
--- /dev/null
+++ b/include/configs/edm-cf-imx6.h
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2015 Technexion Ltd.
+ *
+ * Author: Richard Hu <richard.hu@technexion.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <config_distro_defaults.h>
+#include "mx6_common.h"
+
+#include "imx6_spl.h"
+
+#define MACH_TYPE_EDM_CF_IMX6		4257
+#define CONFIG_MACH_TYPE		MACH_TYPE_EDM_CF_IMX6
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* SATA Configuration */
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x10000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 500 * SZ_1M)
+
+
+/* I2C configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1         /* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2         /* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3         /* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED            100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+
+/* MMC Configuration */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_BOUNCE_BUFFER
+
+/* USB Configs */
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+
+/* Ethernet Configuration */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		1
+#define CONFIG_PHY_ATHEROS
+
+/* Framebuffer */
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IPUV3_CLK 260000000
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+#define CONFIG_MXC_GPIO
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+/* Command definition */
+
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"console=ttymxc0,115200\0" \
+	"splashpos=m,m\0" \
+	"bootargs=console=${console} rootfstype=ext4 rootwait\0" \
+	"fdtfile=undefined\0" \
+	"fdt_high=0xffffffff\0" \
+	"fdt_addr_r=0x18000000\0" \
+	"fdt_addr=0x18000000\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"findfdt="\
+		"if test $board_rev = MX6Q ; then " \
+			"setenv fdtfile imx6q-edm1-cf_fairy.dtb; fi; " \
+		"if test $board_rev = MX6DL ; then " \
+			"setenv fdtfile imx6dl-edm1-cf_fairy.dtb; fi; " \
+		"if test $fdtfile = undefined; then " \
+			"echo WARNING: Could not determine dtb to use; fi; \0" \
+	"kernel_addr_r=" __stringify(CONFIG_LOADADDR) "\0" \
+	"scriptaddr=" __stringify(CONFIG_LOADADDR) "\0" \
+	BOOTENV
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(MMC, mmc, 1)
+
+#define CONFIG_BOOTCOMMAND \
+	"run findfdt; " \
+	"run distro_bootcmd"
+
+#include <config_distro_bootcmd.h>
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+#define CONFIG_SYS_DCACHE_OFF // remove when sata driver support cache
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#endif			       /* __CONFIG_H * */
-- 
2.7.4

